1、数据封装：应用层、传输层、网络层、数据链路层  
2、TCP面向流的滑动窗口确认机制：窗口大小  
3、细说TCP重传：超时重传和重复ACK的快速重传  
  TCP片段重传计时器以及重传队列  
4、细说TCP确认机制：未确认片段处理策略：1、仅重传超时片段、2、重传所有片段：3、选择确认SACK  
5、TCP窗口调整与流控：接收方可以在确认信息中，将窗口大小从260字节缩减为80字节  
  
6、HTTP请求和响应：header和 body  
http响应码  
  
7、DNS：域名系统  
  PING作用：是否有连接和连接的质量如何  
  traceroute www.baidu.com：查看到目标地址经过了多少个路由器  
  NAT原理：网络地址转换  
  
8、Wireshark抓包解决：  
  TCP连接问题  
  TCP重传：超时重传和快速重传  
  TCP重复ACK快速重传、乱序  
  TCP窗口及reset  
  HTTP问题  
    
9、网络路径性能检测：  
  带宽测量：ping 手动计算、pathchar 自动计算、bing  
  吞吐量测量：ftp、ttcp、netperf、iperf、treno  
  数据流测量：netstat  
  
10、TCP流程  
11、网络优化之net.ipv4.tcp_tw_recycle参数  
12、TCP参数  
13、  
14、  
---------------------------------------------------------------------------------------------------------------------  
  
TCP流程  
TCP三次握手建立连接-->传输-->TCP四次挥手关闭、RST异常关闭  
传输：  
1、数据封装：  
2、TCP滑动窗口（客户端和服务端）：  
3、ACK确认、TCP窗口调整与流控：重复ACK、  
4、TCP重传：超时重传和重复ACK快速重传：重传单个片段、重传所有片段、选择确认SACK  
  
  
  
就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。  
  
RST：reset，是强制关闭TCP连接，不处理扫尾工作立即关闭连接，是一种异常时关闭连接的操作，缓冲区数据可能会丢失，或者有未发送完的数据  
FIN报文是正常关闭连接，需要两端各发送一个FIN报文，最后再断开连接  
  
TIME_WAIT 2MSL的作用：  
1、可靠地实现TCP全双工连接的终止  
2、允许老的重复TCP分节在网络中消逝    
主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。  
  
  
  
---------------------------------------------------------------------------------------------------------------------  
https://wizardforcel.gitbooks.io/network-basic/content/6.html  
  
数据封装:  
消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。  
  
协议数据单元（Protocol Data Unit, PDU）  
数据片段在各层网络结构中采用的形式就称为协议数据单元（PDU）。封装过程中，下一层对从上一层收到的PDU进行封装。在处理的每一个阶段PDU都有不同的名字来反应它的功能。  
  
PDU按照TCP/IP协议的命名规范：  
数据（Data）：应用层PDU的常用术语  
分段（Segment）：传输层PDU  
帧（Frame）：网络层PDU  
比特（Bits）：在介质上物理传输数据所使用的PDU。  
  
  
  
应用层：HTTP（请求头、请求体）  
传输层：TCP/UDP（接收进程信息、重组数据的信息）  
网络层：IP（Source IP 和 Destination IP）  
数据链路层：帧头：MAC地址（Source MAC地址 和 Destination MAC地址）、帧尾(差错校正信息)  
  
  
1、应用层：HTTP：应用协议HTTP报文头添加到HTML数据之前。报文头信息包括：服务器所使用的HTTP版本，以及表明它包含发给网络客户端信息的状态编码。  
2、传输层：TCP/UDP：HTTP应用层协议发送HTML格式网页数据到传输层，应用层数据被分成TCP分段。各TCP分段被打上标签，称为头（header），表明接收方哪一个进程应当接收此消息。同时也包含使得接收方能够按照原有的格式来重组数据的信息。  
3、网络层：IP：整个TCP分段封装成IP报文，也就是再添上IP头标签。IP头包括源和目的IP地址，以及发送报文到目的地址所必须的信息。  
4、数据链路层：IP报文发送到接入层，封装以帧头和帧尾。每个帧头都包含源和目的物理地址。物理地址唯一指定了本地网络上的设备。帧尾包含差错校正信息。最后，由服务器网卡将比特编码传输给介质。  
  
  
  
将TCP与UDP这样的简单传输协议区分开来的是它传输数据的质量。TCP对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：  
1、可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。  
2、数据流控：管理数据的发送速率，以使接收设备不致于过载。  
  
TCP面向流的滑动窗口确认机制  
1. 已发送已确认 数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。如下图所示，31个字节已经发送并确认。  
2. 已发送但尚未确认 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。下图所示14字节为第2类。  
3. 未发送而接收方已Ready 设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。如图，第3类有6字节。  
4. 未发送而接收方Not Ready 由于接收方not ready，还不允许将这部分数据发出。  
  
窗口大小就是2+3  
  
  
  
细说TCP重传：超时重传和重复ACK的快速重传  
TCP片段重传计时器以及重传队列  
  
重传队列中所使用片段重传计时器的值。如果设置过低，会发生过量重传，如果设置过高，重传丢失片段会减弱性能。必须通过一个称为自适应重传的过程来动态调整这个值  
  
细说TCP确认机制：  
未确认片段处理策略  
1、仅重传超时片段：这是一种更加保守的方式，仅重传超时的片段，希望其他片段都能够成功接收。  
2、重传所有片段：这是一种更激进或者说更悲观的方式。无论何时一个片段超时了，不仅重传该片段，还有所有其他尚未确认的片段。  
  
问题的关键在于无法确认非连续片段。解决方式是对TCP滑动窗口算法进行扩展，添加允许设备分别确认非连续片段的功能。这一功能称为选择确认（selective acknowledgment, SACK）。  
  
选择确认SACK：  
1、接收端不进返回确认号，还返回SACK选项，预确认，重传队列把预确认的片段的SACK比特位置为1  
2、重传所有片段，但是SACK比特位为1已经被预确认的片段不重传，并去除SACK比特位标识  
3、若计时器超时的情况接收端没有返回之前预确认片段，则会对其自动重传。  
  
  
TCP窗口调整与流控：接收方可以在确认信息中，将窗口大小从260字节缩减为80字节  
  
减小窗口大小以降低发送速率  
缩减发送窗口以停止发送新数据  
将窗口减小为0，也称为关闭窗口  
  
  
  
PING作用：是否有连接和连接的质量如何  
ping的工作原理很简单，一台网络设备发送请求等待另一网络设备的回复，并记录下发送时间。接收到回复之后，就可以计算报文传输时间了。只要接收到回复就表示连接是正常的。  
耗费的时间喻示了路径长度。  
重复请求响应的一致性也表明了连接质量的可靠性。  
因此，ping回答了两个基本的问题：是否有连接？连接的质量如何？  
  
  
ping www.bay.com -c 4  
ping www.bay.com -s 128  
  
-c选项允许用户指定发送报文的数量。例如，ping –c10会发送10个报文然后停止。这一命令在脚本中很有用处。  
-s选项指定发送数据的大小。但如果设置的太小，小于8，则报文中就没有空间留给时间戳了。设置报文大小能诊断有路径MTU(Maximum Transmission Unit)设置或分段而导致的问题。如果不使用该选项，ping默认是64字节。  
  
“TTL”是生存时间（Time To Live）的意思  
“TTL”是 Time To Live 的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。  
  
字节代表数据包的大小，时间顾名思义就是返回时间，“TTL”的意思就是数据包的生存时间，当然你得到的这个就是剩余的生存时间。TTL用来计算数据包在路由器的消耗时间，因为现在绝大多数路由器的消耗时间都小于1s，而时间小于1s就当1s计算，所以数据包没经过一个路由器节点TTL都减一。  
  
那么TTL的值一开始是什么呢？不同的操作系统默认下TTL是不同的。默认情况下，Linux系统的TTL值为64或255，Windows NT/2000/XP系统的TTL值为128，Windows 98系统的TTL值为32，UNIX主机的TTL值为255。  
  
TTL貌似可以估算一条路径上的跳数，但是这有一些问题。当发送报文时，TTL字段先被初始化接着经过路径上每个路由器都要递减。如果达到0，报文就被丢弃了。从而对所有报文生命周期有一定限制。因而在路由回环的过程中，报文不会无期限存在于网络上。不幸的是，TTL字段可能会，也可能不会被远端设备重置，如果重置，也没有一致性。因此，要使用TTL字段估算路径中的跳数需要知道详细的系统信息。  
  
  
  
查看到目标地址经过了多少个路由器  
tracert [目标]  
MAC上是traceroute www.baidu.com  
  
  
  
  
NAT原理  
NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。因此我们可以认为，NAT在一定程度上，能够有效的解决公网地址不足的问题。  
  
NAT有三种类型：静态NAT(Static NAT)、动态地址NAT(Pooled NAT)、网络地址端口转换NAPT（Port-Level NAT）。  
  
  
  
ICMP（Internet Control Message Protocol）是网络控制消息协议，主要用于传递查询报文与差错报文。  
ARP(Address Resolution Protocol)是地址解析协议，它的作用是在以太网环境下，通过3层的IP地址来找寻2层的MAC地址，得到一张ARP缓存表。转发数据的时候根据ARP缓存表来进行传输。  
  
尽管Internet上的每台设备都有一个或多个IP地址，仅用这些地址仍然不能发送报文。数据链路层网卡如以太网卡不理解Internet地址。对于以太网，每一个以太网卡都有一个48bit的以太网地址。网卡基于这48bit以太网地址收发帧，网卡与32bit IP地址没有关系。  
  
  
  
  
HTTP是一个由请求与响应组成的客户端与服务端交互协议。浏览器发送一个HTTP请求到指定的URL地址，持有此URL地址的WEB服务器将返回一个HTTP请求。请求的类型有GET, POST, HEAD, PUT, DELETE, OPTIONS和TRACE等。  
  
响应码和文本描述  
1xx：指示信息——表示请求已经接受，继续处理  
2xx：成功——表示请求已经被成功接收、理解、接受。  
3xx：重定向——要完成请求必须进行更进一步的操作  
4xx：客户端错误——请求有语法错误或请求无法实现  
5xx：服务器端错误——服务器未能实现合法的请求。  
  
常见状态代码、状态描述、说明：  
200 OK      //客户端请求成功  
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解  
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用  
403 Forbidden  //服务器收到请求，但是拒绝提供服务  
404 Not Found  //请求资源不存在，eg：输入了错误的URL  
500 Internal Server Error //服务器发生不可预期的错误  
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常  
  
  
响应的数据  
Location（重定向）  
Content-Type实体头用于向接收方指示实体的介质类型  
Expires： 给出响应过期的日期和时间。通常，代理服务器或浏览器会缓存一些页面  
Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。   
  
  
  
域名系统（英文：Domain Name System，缩写：DNS）  
因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。  
  
  
  
  
  
Wireshark抓包实例诊断TCP连接问题：  
总结：  
1、如果SYN报文收到回复RST，则检查拦截了port号的防火墙。  
2、三次SYN而没有任何回复，或者是由于应用程序没有响应，或者是由于防火墙拦截了特定端口上的请求。  
3、永远记住确认一下是否有NAT，端口转发，以及涉及TCP和UDP端口的机制。这些机制可能会中断TCP正常操作。  
  
  
Wireshark抓包实例分析TCP重传：超时重传和快速重传  
当发现网速变慢时，原因之一可能就是重传。  
TCP发送一个或一组报文，会等待收到报文的确认信息。重传，即发生在报文没有到达或确认信息没有及时返回的情况下。  
  
  
Case 1：重传至多个目的地址  
以下截屏中，可看到有多次重传，分布于多台服务器，目的端口号为80（HTTP）。也可以发现重传由端口10.0.0.5发送，因此报文是丢失在发往Internet的途中，或确认信息没有及时从web服务器发回。  
引起重传的原因：报文丢失及错误。  
  
Case 2：重传至单一连接  
如果所有重传发生于同一IP，同一TCP端口号，则可能是慢速应用引起。  
  
  
Case 4：应用无响应导致重传  
另一个可能导致重传的原因是客户端或服务器没有响应请求。这种情况下，会看到五次重传，时间也会逐渐延长。五次连续重传后，发送方认为连接断开（某些情况下，会发送reset来关闭连接，取决于软件实施）。断开连接之后，可能会发生两件事情：  
发送SYN请求至客户端，以打开一个新的连接。这种情况下用户会看到应用冻结，过了15-20秒之后重新开始工作。  
不发送SYN，用户需要重新运行应用程序（或应用程序的一部分）  
  
  
Wireshark抓包实例分析TCP重复ACK与乱序  
重复ACK：客户端发送的  
当发现有丢失报文时（期望的序列号没有收到），或者收到了预期之外的序列号。这种情况下，接收端生成一个ACK，声明自己希望收到的下一个序列号。接收方持续生成丢失片段的ACK请求，直到实际收到。  
  
快速重传：是对重复ACK的响应报文。  
在发送方，当它收到三个相同的ACK（初始ACK和两个重复ACK），就会假设有报文丢失并重传该报文，无论重传计时器是否过期。再次发送的报文称为快速重传。  
  
重复ACK也减少了发往网络的吞吐量。减少了多少吞吐量取决于TCP版本。比较早期的TCP版本中出现了重复ACK，发送方将吞吐量减少为之前的一半。在多个DupACK的情况下，吞吐量减到最小。  
  
  
乱序报文:  
在两端抓包，乱序情况下需要关注三种现象：  
1、先前片段丢失：当前收到报文的序列号高于该连接的下一个期望序列号时，表明之前的一个或多个报文未能到达  
2、乱序报文：当前报文的序列号低于该连接先前收到的报文，走的是不同的路径（不同的路由器）  
3、先前片段未能捕捉：（Wireshark 1.8.x及以上版本）：同先前报文丢失。  
  
  
总结  
乱序报文的原理很简单。TCP发送以其字节数为编号的报文到接收方。当一个报文没有按照顺序到达时，Wireshark就会注意到。原因有两点：  
1、确实有问题：这时会看到重传和重复ACK，这是TCP对于收到乱序报文的响应。  
2、抓包问题：这时仅看到乱序报文，但没有看到对可能丢失及乱序报文的响应，可能实际上并没有问题。  
  
确实有问题，就要查看链路是不是有问题，比如Tracert查看链路上路由器，ping看一下延时  
  
  
  
Wireshark抓包实例分析TCP窗口及reset  
TCP最重要的机制之一是滑动窗口机制，以及用以控制TCP终端节点愿意接收的数据总量的流控机制。  
  
TCP窗口问题:TCP零窗口，零窗口探测，零窗口违例、TCP窗口更新、TCP窗口已满  
  
TCP零窗口发生于接收方在TCP头部的window字段广播接收窗口零字节的时候。这一事件告知发送方停止发送数据，因为接收方缓存已满。这也表明接收方可能发生以下问题：  
1、服务器无法为进程分配组后的内存  
2、应用碰到没有足够内存的问题，因此TCP需告知发送方停止发送数据  
3、应用消耗太多内存因此操作系统要限制应用资源  
  
TCP零窗口探测由发送方发出，以查看接收方的零窗口是否依然存在。这一消息通过发送下一字节数据给接收方，如果接收方回复窗口大小仍然为零，则发送方的探测计时器加倍。  
  
TCP窗口违例：发送方忽略接收方的零窗口大小并发送额外字节数据。TCP零窗口违例表明协议栈中有TCP错误。为了检查是何问题，检查是否有以下事件：  
1、某一终端设备（服务器或客户机）报出终端设备故障  
2、某一应用报出常规应用错误  
3、应用中执行某一操作时报错，例如，打开一个表格，发送一份文件至打印机，创建一个报告，或其他操作。这种情况下，是应用问题。  
  
TCP窗口更新  
TCP将窗口更新发送至连接的对端，以表明缓存大小更改，并且准备好接受更高或更低的数据速率（缓存大小决定了发送方被允许的发送速率）。这一情况发生于：  
1、TCP接收方从零窗口中恢复，告知发送方重新发送速率。这一情况下，无需进行处理，只需检查第一次导致零窗口的问题。  
2、TCP接收方频繁更改窗口大小。该情况下检查接收方被干扰的原因。可能是应用问题，内存问题，或终端设备上的其他问题。  
看到这类现象无需担心，这就是TCP的工作机制。  
  
TCP窗口已满  
这一信息表明已发送的报文会完全填满接收方的接收缓存。发生于接收方没有对先前接收到的数据发出任何ACK确认信息，因此，这将会成为发送方从接收方收到ACK之前的最后一个报文数据。  
这一事件的触发原因与触发零窗口的原因相同，是服务器或应用无响应的标志。  
  
  
工作原理  
  
TCP滑动窗口机制如下：  
1、连接建立之后，发送方将数据发送至接收方，填入接收窗口。  
2、若干报文之后，接收方发送ACK至发送方，确认接收到其发送的字节数。发送ACK将接收窗口清零。  
3、这一过程持续下去，发送方向窗口中填入数据，接收方清空并发送确认信息。  
4、扩大接收窗口大小告知发送方增加吞吐量，减小窗口告知对方减小吞吐量。这一机制按照WS/RTT规则（随着TCP版本不同而有所改变）：  
  
  
TCP reset及原因:  
  
reset是用以告知接收方断开连接的TCP信号，通过将RST标志位置1来发送。正常的操作过程中，TCP通过SYN信号打开连接，通过FIN信号关闭连接。TCP的一大特性在于有问题时，或只是为了更好的性能，它能够快速关闭连接。  
  
1、无故障时发送reset  
  TCP关闭连接的标准方式是通过FIN和FIN-ACK信号。为了关闭连接，用户需要四个报文：来自一方的FIN/ACK和ACK，以及另一方的同样报文。当你打开一个网页，可能同时打开了数十个连接（主页，新闻，广告，定期更新的图片等），要关闭所有这些有时需要数百个FIN和FIN-ACK报文。为了防止其发生，web服务器在很多情况下会在发送请求数据之后用reset断开连接。这是标准的做法，并取决于应用程序。  
  
2、有故障时发送reset  
  某些情况下reset表明有故障发生（并不一定是通信故障）：  
    
  防火墙发送的reset：当远端服务器尝试打开连接但没有结果时，也许会看到返回RST信号。这是防火墙阻隔连接的情况。下图中，可看到发送的每一个SYN都返回以RST。  
    
  由于收发一方有问题发送的reset：可能的原因如：  
  1、五个连续没有收到ACK回复的重传。当发送方没有收到任何重传回复，它就会发送一个reset信号到对端，告知其断开连接。  
  2、另一个原因是连接之上几分钟都没有任何数据（分钟数取决于系统默认）。打开连接的一方通常会发送reset（但并不总是会这样做，取决于实现方式）。  
  
  
  
Wireshark抓包实例分析HTTP问题  
  
诊断过程:  
浏览网页性能变差的原因有很多，需要逐步分析。步骤如下：  
1、首先，不仅要确认网络负载状况，还要注意通信链路上的出错率，以及导致性能变差的最明显的表现；  
2、诊断TCP问题，检查以下细节：  
  在Expert info窗口，确保没有太多重传以及重复ACK（百分之0.5至0.8尚可忍受）。  
  确保HTTP连接上没有reset，可能由于防火墙或站点限制引发。  
3、确保没有以下DNS问题：  
  慢速响应时间  
  域名未找到  
    
注意：将网络和IT环境看作一个整体。对于慢速网络浏览应用，TCP问题亦不能分离于HTTP，DNS问题。可能是由于慢速HTTP服务器，因服务器的慢速响应而产生了TCP重传。或者，由于DNS慢速服务器，打开网页可能需要好几秒钟。一步步定位问题就好了。  
  
当你第一次打开一个网页，可能需要几秒钟。在这种情况下，应当查看以下情况：  
1、检查线路是否过载  
2、检查线路延时（通过ping工具）  
3、查看错误代码，通常能看到浏览器报错原因，但并不总是能看到。  
4、配置过滤器http.response >= 400并查看有多少错误。以下章节，你会看到需要注意的示例。  
  
工作原理:  
标准的HTTP浏览模式如下：  
1、TCP打开连接（三路握手信号）  
2、HTTP发送GET命令  
3、数据下载到浏览器  
在一个网页打开多个连接的情况下（大多数网页都是如此）。每个连接需要一个DNS 查询，响应，TCP SYN-SYN/ACK-ACK，以及HTTP GET。之后数据才会出现在显示屏上。  
当你在packet detail面板没有看到显示内容时，右键报文并选择Follow TCP stream，会看到连接的细节数据。另一个广泛应用的工具是Fiddler，Fiddler是HTTP故障排查的免费工具。  
  
  
  
  
  
  
网络路径性能检测主要包括三方面的内容：  
带宽测量能够获知网络的硬件特性，如网络的最大容量，  
吞吐量测量能够获得网络实际可提供的最大容量，  
数据流测量能够了解真实占用的网络容量。  
  
  
  
带宽测量：  
1、ping 手动计算  
2、pathchar 自动计算  
3、bing pathchar的一个替代工具是bing。pathchar估算的是一条路径上各链路的带宽，而bing用来测量点到点的带宽。通常，如果你不知道路径上的各条链路，需要首先执行traceroute命令。之后可以运行bing来指定链路的近端和远端。下例显示了第三跳的带宽：  
bsd1# bing -e10 -c1 205.153.60.2 165.166.36.17  
  
  
  
吞吐量测量:  
1、FTP：  
一个比较简单粗放的方式是用FTP。用FTP来传输一份文件并且看一下它report的数据。需要将结果转换成比特率，例如，这是文件传输的最后一行：  
1294522 bytes received in 1.44 secs (8.8e+02 Kbytes/sec)  
将1,294,522字节乘8转换成bit之后再除以时间，1.44秒。 结果为7,191,789 bps。  
这种方法的不足在于磁盘访问时间可能对结果造成影响。如果需要提高精度则需要使用一些工具。  
  
2、ttcp  
运行这一程序首先需要在远端设备运行server，通常用-r和-s选项。之后运行client，用-t和-s选项，以及主机名或地址。数据从client端发送至server端，测量性能之后，在各端返回结果，之后终止client端和server端。  
Server端：bsd2# ttcp -r -s  
Client端：bsd1# ttcp -t -s 205.153.63.239  
  
3、netperf：也是 server/client 模式  
与ttcp不同，客户端和服务器端是分开的程序。服务器端是netserver，能够单独启动，或通过inetd启动。客户端是netperf。  
下例中，服务器和客户端启动于同一台机器：  
bsd1# netserver  
bsd1# netperf  
  
下例中，netserver启动于主机：  
bsd1# netserver  
netperf加上-H选项指定服务器地址：  
bsd2# netperf -H 205.153.60.247  
以下测试中，还计算了连接的transaction rate：  
bsd2# netperf -H 205.153.60.247 -tTCP_RR  
执行一次持续10秒的 TCP 测试：  
# netperf -H 172.16.38.36 -l 10    
  
4、iperf：也是 server/client 模式  
如果ttcp和netperf都不符合你的要求，那么可以考虑iperf。iperf也可以用于测试UDP带宽，丢失率，和抖动。Java前端让该工具便于使用。该工具同样移植入windows。  
  
下例是运行iperf服务器端：  
bsd2# iperf -s -p3000  
  
下例是在windows运行客户端：  
C:\>iperf -c205.153.60.236 -p3000  
  
  
先在服务器端启动 iperf：  
# iperf -s -D    
  
客户端先连接到服务器端（172.16.38.36），并在30秒内每隔5秒对服务器和客户端之间的网络进行一次带宽测试和采样：  
# iperf -c 172.16.38.36 -t 30 -i 5    
  
  
注意使用Ctrl-C来终止服务器端。在TCP模式下，iperf相当于ttcp，所以它可盈用户客户端或服务器。  
在研究TCP窗口是否足够大时，使用iperf特别方便。-w选项设置socket buffer大小。对于TCP来说，这就是窗口大小。通过-w选项，用户可以单步调试各种窗口大小来看它们是怎样影响吞吐量的。  
  
5、treno使用的方法类似于traceroute来计算块容量，路径MTU，以及最小RTP。如下例所示：  
  bsd2# treno 205.153.63.30  
   
 通常来说，netperf，iperf和treno提供更加丰富的feature，但ttcp更加容易找到。  
  
  
  
tcpdump 和 tcptrace  
    tcmdump 和 tcptrace 提供了一种更细致的分析方法，先用 tcpdump 按要求捕获数据包把结果输出到某一文件，然后再用 tcptrace 分析其文件格式。这个工具组合可以提供一些难以用其他工具发现的信息：  
# /usr/sbin/tcpdump -w network.dmp    
    
# tcptrace network.dmp    
  
tcptrace 功能很强大，还可以通过过滤和布尔表达式来找出有问题的连接，比如，找出转播大于100 segments 的连接：  
# tcptrace -f'rexmit_segs>100' network.dmp  
如果发现连接 ＃10 有问题，可以查看关于这个连接的其他信息：  
# tcptrace -o10 network.dmp  
  
下面的命令使用 tcptrace 的 slice 模式，程序自动在当前目录创建了一个 slice.dat 文件，这个文件包含了每隔15秒的转播信息:  
# tcptrace -xslice network.dmp    
# cat slice.dat    
  
  
  
通过netstat进行流量测量:  
在理想的网络环境下，如果把overhead算在内，吞吐量是很接近于带宽的。但是吞吐量往往低于期望值，这种情况下，你会想要知道差异在哪。如之前所提到的，可能与硬件或软件相关。但通常是由于网络上其他数据流的影响。如果你无法确定原因，下一步就是查看你网络上的数据流。  
有三种基本方法可供采用。第一，最快的方法是使用如netstat这样的工具来查看链路行为。或通过抓包来查看数据流。最后，可使用基于SNMP的工具如ntop。  
要得到网络上数据流的快照，使用-i选项。举例来说：  
bsd2# netstat -i  
  
netstat -antp  
  
列出所有 tcp与udp 端口  
netstat -tulnp  
  
  
如果你只想要单一接口的输出，可以通过-I选项指定，如：  
bsd2# netstat -Iep0  
  
  
  
命令  
sar -n { DEV | EDEV | NFS | NFSD | SOCK | ALL }  
  
命令参数  
sar 提供六种不同的语法选项来显示网络信息。  
-n选项使用6个不同的开关：DEV | EDEV | NFS | NFSD | SOCK | ALL 。  
DEV显示网络接口信息，  
EDEV显示关于网络错误的统计数据，  
NFS统计活动的NFS客户端的信息，  
NFSD统计NFS服务器的信息，  
SOCK显示套接字信息，  
ALL显示所有5个开关。  
  
应用示例sar -n SOCK 2 10  
  
  
  
  
ISP(Internet Service Provider)，互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务和增值业务的电信运营商。  
ICP（Internet Content Provider）是互联网内容提供商，向广大用户综合提供互联网信息业务和增值业务的电信运营商。  
在互联网应用服务产业链“设备供应商——基础网络运营商——内容收集者和生产者——业务提供者——用户”中，ISP/ICP处于内容收集者、生产者以及业务提供者的位置。  
  
  
  
网络地址转换NAT原理  
https://blog.csdn.net/hzhsan/article/details/45038265  
  
  
  
TCP中的RST标志(Reset)详解  
https://blog.csdn.net/erlib/article/details/50132307  
  
tcp连接全过程各种状态详解  
https://blog.csdn.net/hkhl_235/article/details/79721645  
  
说明TCP中的SYN、RST、FIN中 含义，及其可能出现的扫描攻击  
https://www.cnblogs.com/ianthe/articles/3658307.html  
  
  
netstat命令详解  
https://blog.csdn.net/m0_37556444/article/details/83000553  
https://blog.csdn.net/shaochenshuo/article/details/56665641  
  
  
---------------------------------------------------------------------------------------------------------------------  
  
网络优化之net.ipv4.tcp_tw_recycle参数  
  
表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。  
这个只能用在Client，解决client可用端口不够用情况，Cannot assign requested address问题  
不能用在Server，并且不能用在NAT后端的Client，对于位于NAT设备后面的Client来说，是一场灾难——会导到NAT设备后面的Client连接Server不稳定（有的Client能连接server，有的Client不能连接server）。  
  
  
  
参考/Users/yangzl/git/quickstart-http/docs/HTTP学习.md中的  
Cannot assign requested address问题总结：压测出现的问题  
  
  
在NAT(Network Address Translation)网络下，会导致大量的TCP连接建立错误。  
  
当tcp_tw_recycle开启时（tcp_timestamps同时开启，快速回收socket的效果达到），对于位于NAT设备后面的Client来说，是一场灾难——会导到NAT设备后面的Client连接Server不稳定（有的Client能连接server，有的Client不能连接server）。也就是说，tcp_tw_recycle这个功能，是为“内部网络”（网络环境自己可控——不存在NAT的情况）设计的，对于公网，不宜使用。  
  
通常，“回收”TIME_WAIT状态的socket是因为“无法主动连接远端”，因为无可用的端口，而不应该是要回收内存（没有必要）。即，需求是“Client”的需求，Server会有“端口不够用”的问题吗？除非是前端机，需要大量的连接后端服务——即充当着Client的角色。  
正确的解决这个总是办法应该是：  
net.ipv4.ip_local_port_range = 9000 6553 #默认值范围较小  
net.ipv4.tcp_max_tw_buckets = 10000 #默认值较小，还可适当调小  
net.ipv4.tcp_tw_reuse = 1 #  
net.ipv4.tcp_fin_timeout = 10 #  
  
  
  
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；  
net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。  
需要net.ipv4.tcp_timestamps（默认开启的）这个开关开启才有效果。  
  
  
参考  
https://blog.csdn.net/enweitech/article/details/79261439  
https://blog.csdn.net/qw3672939/article/details/83746604  
  
  
  
---------------------------------------------------------------------------------------------------------------------  
  
TCP参数  
  
参考  
/Users/yangzl/git/quickstart-framework/quickstart-document/doc/base/操作系统/Linux/TCP参数.md  
  
  
---------------------------------------------------------------------------------------------------------------------  
  
  
  
